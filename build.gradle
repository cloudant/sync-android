// ************ //
// COMMON STUFF
// ************ //

apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'signing'

//
// General settings
//

allprojects {
    group = 'com.cloudant'
    version = '1.0.1-SNAPSHOT'
    description = """cloudant-sync"""
    //if the version says "snapshot" anywhere assume it is not a release
    ext.isReleaseVersion = !version.toUpperCase(Locale.ENGLISH).contains("SNAPSHOT")

    // Load signing parameters from system properties
    ['signing.keyId', 'signing.password', 'signing.secretKeyRingFile']
            .each { propName ->
        // Set a property with the given name if the system property is set
        if (System.properties.(propName.toString()) != null) {
            ext.(propName.toString()) = System.properties.(propName.toString())
        }
    }
}

dependencies {
    compile project(':cloudant-sync-datastore-core')
    compile project(':cloudant-sync-datastore-javase')
    compile project(':cloudant-sync-datastore-android')
    compile project(':cloudant-sync-datastore-android-encryption')
}

subprojects {

    apply plugin: 'java'
    apply plugin: 'maven'
    apply plugin: 'maven-publish'
    apply plugin: 'signing'

    signing {
        // Only apply signing when it is a release and is being published
        required {
            isReleaseVersion
        }

        // When signing, sign the archives
        sign configurations.archives
    }

    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
    }

    //
    // Build plugins
    //

    buildscript {
        repositories {
            mavenCentral()
        }
        dependencies {
            classpath "net.saliman:gradle-cobertura-plugin:2.1.0"
        }
    }

    sourceCompatibility = 1.6
    targetCompatibility = 1.6

    defaultTasks 'build'

    repositories {
        mavenLocal()
        mavenCentral()
    }

    //
    // Misc. tasks
    //

    task listJars << {
        configurations.testCompile.each { File file -> println file.name }
    }

    //findbugs
    apply plugin: 'findbugs'
    findbugs {
        toolVersion = "3.0.1"
        reportLevel = System.getProperty("findbugs.report.level","high")
        //the code base is pretty small so use max effort
        effort = "max"
        // We don't want to run findbugs on the test code yet
        sourceSets = [sourceSets.main]
        // Exclude a couple of known bugs until we get the chance to fix them
        if (file("findbugs_excludes.xml").exists()) {
            excludeFilter = file("findbugs_excludes.xml")
        }
    }
    tasks.withType(FindBugs) {
        // Currently only one report type can be used toggle which with a property
        boolean generateXML = Boolean.getBoolean("findbugs.xml.report")
        reports {
            xml.enabled = generateXML
            html.enabled = !generateXML
        }
    }

    //
    // *** DOCS AND PUBLISHING ***
    //

    // see http://issues.gradle.org/browse/GRADLE-1876
    // run javadoc over union of all projects
    gradle.projectsEvaluated {

      // task to invoke custom doclet to audit public/private API tags
      task auditApi(type: Javadoc, dependsOn: ':cloudant-sync-datastore-core:compileToolsJava') {
        // for some reason classpath is not already configured
        classpath = project.sourceSets.main.compileClasspath
        // tools.jar also needs to be on the classpath for javadoc
        classpath += files(org.gradle.internal.jvm.Jvm.current().toolsJar)
        options.doclet = "com.cloudant.doclet.ApiAuditDoclet"
        // doclet lives in the 'tools' path of the core project
        options.docletpath = [project(':cloudant-sync-datastore-core').sourceSets.tools.output.classesDir]
        source project.sourceSets.main.allJava
      }
      
      javadoc {

            options.encoding = "UTF-8"
            options.docEncoding = "UTF-8"
            options.charSet = "UTF-8"
            options.tags = ['api_public:tp:API Status: Public',
                            'api_private:tp:API Status: Private - API users are discouraged from using this class as fields, method signatures, and implementation details may be subject to change']
            options.showFromPublic()
            title = "sync-android ${version} API"

            // For the subprojects we include all the javadoc from dependencies on other subprojects
            // this produces a more standalone javadoc jar for each published artifact.
            source getProjectDocSources(project).collect() { dsp ->
                        dsp.sourceSets.main.allJava
            }
        }
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        classifier = 'javadoc'
        from javadoc.destinationDir
    }

    task sourcesJar(type: Jar, dependsOn: classes) {
        classifier = 'sources'
        sourceSets.all {
            into(name + "/java", { from allJava })
            into(name + "/resources", { from resources })
        }
    }

    artifacts {
        archives sourcesJar, javadocJar
    }

    uploadArchives {
        ext.ossrhUsername = System.properties.ossrhUsername
        ext.ossrhPassword = System.properties.ossrhPassword

        doFirst {
            // If the OSSRH credentials are not available, then fail the build
            if (ossrhUsername == null || ossrhPassword == null) {
                throw new GradleException('OSSRH credentials properties (ossrhUsername & ' +
                        'ossrhPassword) are required to upload archives.')
            }
        }

        repositories {
            mavenDeployer {
                //when publishing sign the pom
                beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }

                repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2/") {
                    authentication(userName: ossrhUsername, password: ossrhPassword)
                }

                snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots/") {
                    authentication(userName: ossrhUsername, password: ossrhPassword)
                }

                //augment the pom with additional information
                pom.project {
                    packaging 'jar'
                    inceptionYear '2013'
                    url 'https://cloudant.com'
                    licenses {
                        license {
                            name 'The Apache Software License, Version 2.0'
                            url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                            distribution 'repo'
                        }
                    }
                    scm {
                        connection 'scm:git:git://github.com/cloudant/sync-android.git'
                        developerConnection 'scm:git:git@github.com/cloudant/sync-android.git'
                        url 'https://java-cloudant@github.com/cloudant/sync-android.git'
                    }
                    properties {
                        'project.build.sourceEncoding' 'UTF-8'
                    }
                    developers {
                        developer {
                            name 'IBM Cloudant'
                            email 'support@cloudant.com'
                            url 'https://cloudant.com'
                            organization 'IBM'
                            organizationUrl 'http://www.ibm.com'
                        }
                    }
                }
            }
        }
    }

    File dexAllDir = new File(project.buildDir, "dex-all")
    File dexAllInputDir = new File(dexAllDir, "in")
    File dexAllOutputDir = new File(dexAllDir, "out")
    task copyDependencies(type: Copy) {
        from configurations.runtime
        into dexAllInputDir
    }

    task copyLib(type: Copy, dependsOn: assemble) {
        from jar.destinationDir
        into dexAllInputDir
    }

    task dexAll(type: AndroidExec, dependsOn: [copyDependencies, copyLib]) {
        doFirst {
            dexAllOutputDir.mkdir()
            def writer = new PrintWriter(new File(dexAllOutputDir, "dexInputList.txt"))
            writer.println(dexAllInputDir.absolutePath)
            writer.close()
        }
        inputs.dir dexAllInputDir
        outputs.dir dexAllOutputDir
        workingDir dexAllOutputDir
        commandLine 'bash', '-e', '-c', """
            dx --dex --statistics --num-threads=4 --core-library --output=all.dex --input-list=dexInputList.txt >dex.log 2>&1
        """
    }

    task methodCount(type: Exec, dependsOn: [dexAll]) {
        // Run this task to get the Android method counts.
        workingDir dexAllOutputDir
        commandLine 'bash', '-e', '-c', """
            grep 'method id:.*' dex.log
        """
    }
}

// A gradle Exec task that includes the Android tools on the path.
// Tasks of this type can only execute if sdk.dir is set in local.properties or the ANDROID_HOME
// environment variable is set. It will include the highest found version of the build-tools.
class AndroidExec extends org.gradle.api.tasks.Exec {

    @Override
    Task configure(Closure closure) {
        String androidPath = null;
        File localProperties = new File(getProject().getRootProject().getRootDir(), "local.properties")
        if (localProperties.exists()) {
            Properties properties = new Properties()
            localProperties.withInputStream { instr ->
                properties.load(instr)
            }
            androidPath = properties.getProperty('sdk.dir')
        }

        if(androidPath == null){
            androidPath = System.env.ANDROID_HOME
        }

        if (androidPath != null) {
            // Get the highest build tools version
            def btv = Arrays.asList(new File(androidPath + File.separator + "build-tools").list())
                    .sort().reverse().get(0)

            String[] androidPaths = ["tools", "build-tools" + File.separator + btv, "platform-tools"]
            for (String aPath : androidPaths) {
                environment("PATH", environment.PATH + File.pathSeparator + androidPath
                        + File.separator + aPath)
            }
        } else {
            doFirst { throw new TaskInstantiationException("ANDROID_HOME environment variable or " +
                    "local.properties sdk.dir definition did not exist. " +
                    "Unable to run tasks of type AndroidExec without these properties.")}
        }
        return super.configure(closure)
    }
}

// Function to get project doc sources (i.e. the project and all its dependent projects)
def getProjectDocSources(project) {
    // Get the compile time dependencies
    def projectDependencies = project.configurations.compile.getAllDependencies().withType(ProjectDependency)
    // Get the projects from the dependencies
    def dependentProjects = projectDependencies*.dependencyProject
    // Recurse
    dependentProjects.each { dependentProjects += getProjectDocSources(it) }
    // Finally add the original project
    dependentProjects.add(project)
    // Return without duplicates
    return dependentProjects.unique()
}
